/**
 * Pubsub Service API
 * ## Goal  The goal of this API is to be able to use pubsub on any device and under any condition to build decentralized application. Powerful and well connected machine can use pubsub directly, but different reasons can make that difficult. Notable one are mobile or IOT devices: bad networking (NAT, ...), battery life, available compute or application lifespan.  This API allow to delegate to a more powerful instance or a service provider this role of interacting with pubsub. As this API is asynchronous at its core, it allows to instruct that provider to listen to topics, sleep, and come back later to retrieve messages.   ## Design Principles  - effort is made to allow client to operate with the minimum of requests, and within a limited time window. An example of that is /join that returns before the topic is actually subscribed and ready. - as the real world as shown, there is a gradient of necessary validation of received message, ranging from generic or protocol layer (ex:  deduplicate messages, max message size) to application specific (non-conforming message, abuse ...). All of those would usually be done in the same place if the application directly perform pubsub, but this is not the case here. The choice here is to split those into server side (the generic part, including some form of spam prevention) and the client side (anything that require specific logic or data), and have a way for the client to hint the server about those bad message or PeerID. - provide a versioned API from the start  ## Versioning  This API is expected to be hosted at an URL with a path ending with `/v1`, so that future major versions, if any, can be hosted side by side. An example of that would be `https://pubsub-service.example.com/v1`.  ## Expected Usage Patterns  ### Subscribing to a Topic  This first step to use a pubsub service is to join a topic, and optionally define limits. For example, the following will join the `foo` topic for a maximum of 3600s, have a queue of 10 messages of maximum 1000 bytes, and drop old messages if the queue fills up:  `POST /join?topic=foo&queue-length=10&queue-policy=drop-old&timeout=3600&max-message-size=1000`  The service will confirm with a 202, and returns the effective limits as a confirmation. Those limits can be restricted by the service if they are outside of the maximum advertised in the /discovery endpoints:  ```json {   \"queue-length\": 10,   \"queue-policy\": \"drop-old\",   \"timeout\": 3600,   \"max-message-size\": 1000 } ```  ### Publishing and Reading Messages  We now can publish a message, by passing it as the body of the following request:  `POST /publish?topic=foo`  We can read messages in the queue:  `POST /read?topic=foo&count=2`  Here, we ask for a maximum of 2 messages. The service returns them, and inform us that there is 8 more in the queue, and that 2 have been dropped due to the queue filling up:  ```json {   \"messages-dropped\": 2,   \"messages-remaining\": 8,   \"messages\": [     {       \"from\": \"QmdXGaeGiVA745XorV1jr11RHxB9z4fqykm6xCUPX1aTJo\",       \"data\": \"aGVsbG8gd29ybGQK\"     },     {       \"from\": \"QmdXGaeGiVA745XorV1jr11RHxB9z4fqykm6xCUPX1aTJo\",       \"data\": \"aG93IGFyZSB0aGluZ3MgdG9kYXk/Cg==\"     }   ] } ```  ### Maintaining Active Subscription  To avoid keeping alive irrelevant topic subscriptions, services have a timeout defined per topic. If the client is not active on that topic (/join, /publish, /read or /read-all), the service consider that the client is gone and teardown that subscription. To avoid that, clients should signal liveness with a query to one of those endpoints, which will reset the timeout to the maximum duration defined during /join.  Which endpoint to use is up to the client. For example, a client that does read message might want to periodically /read or /read-all, while a client only writing messages might want to periodically use /join again if not enough messages are published.  ## Multi-Tenant Considerations  This specification doesn't enforce anything about how multi-tenancy should be implemented. It is however expected that an authentication layer (BasicAuth, OAuth, UCAN ...) may be added, which should provide the relevant client identifier to return the appropriate responses for that specific client. This is however not a requirement, as an implementation could serve a single client without authentication. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import DiscoveryResponse from '../model/DiscoveryResponse';
import Failure from '../model/Failure';
import JoinResponse from '../model/JoinResponse';
import ListResponseInner from '../model/ListResponseInner';
import PublishMessageProperty from '../model/PublishMessageProperty';
import ReadAllResponseInner from '../model/ReadAllResponseInner';
import ReadResponse from '../model/ReadResponse';

/**
* Default service.
* @module api/DefaultApi
* @version 1.0.0
*/
export default class DefaultApi {

    /**
    * Constructs a new DefaultApi. 
    * @alias module:api/DefaultApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the discovery operation.
     * @callback module:api/DefaultApi~discoveryCallback
     * @param {String} error Error message, if any.
     * @param {module:model/DiscoveryResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Describe the service configuration and limits
     * Describe the service configuration and limits. This endpoint returns the maximum acceptable settings that a client can ask for.
     * @param {module:api/DefaultApi~discoveryCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/DiscoveryResponse}
     */
    discovery(callback) {
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = DiscoveryResponse;
      return this.apiClient.callApi(
        '/discovery', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the filterPeerID operation.
     * @callback module:api/DefaultApi~filterPeerIDCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Instruct the service about read messages that the client side consider bogus or malicious.
     * One necessary component of pubsub is message filtering. This could be required for various reasons, ranging from technical (re-broadcasted message, maximum size ...) to malicious (spam, abuse ..). Some of those, the most generic, are expected to be handled by the service. On the other side of the spectrum, application logic and data is required to evaluate the validity of a message. This endpoint exist so that client can provide that feedback, which will allow the service to filter messages or prune bad peers.
     * @param {String} topic The name of the pubsub topic.
     * @param {String} peerid The libp2p peer identity.
     * @param {module:api/DefaultApi~filterPeerIDCallback} callback The callback function, accepting three arguments: error, data, response
     */
    filterPeerID(topic, peerid, callback) {
      let postBody = null;
      // verify the required parameter 'topic' is set
      if (topic === undefined || topic === null) {
        throw new Error("Missing the required parameter 'topic' when calling filterPeerID");
      }
      // verify the required parameter 'peerid' is set
      if (peerid === undefined || peerid === null) {
        throw new Error("Missing the required parameter 'peerid' when calling filterPeerID");
      }

      let pathParams = {
      };
      let queryParams = {
        'topic': topic,
        'peerid': peerid
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/filter-peerid', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the join operation.
     * @callback module:api/DefaultApi~joinCallback
     * @param {String} error Error message, if any.
     * @param {module:model/JoinResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Subscribe to a pubsub topic and signal liveness
     * Subscribe to a pubsub topic. The client can define configuration for that topic (queue length, timeout...). Those configuration can be restricted by the server to conform to the server capability (see /discovery). The effective configuration is returned as part of the response. Join is only effective for some duration, defined by the previously described process. In order to keep listening to that topic, the client should perform a /join, /read, /read-all or /publish before expiration, to signal liveliness. This operation is idempotent if the given parameters result in the same configuration, but a different operation should be effective and drop messages if necessary. Note that subscription is not an instantaneous operation and can happen after this request returns. It may take some time before the subscription is processed and effective in the server.
     * @param {String} topic The name of the pubsub topic.
     * @param {Object} opts Optional parameters
     * @param {Number} [queueLength = 20)] The maximum number of pubsub messages stored by the service.
     * @param {module:model/String} [queuePolicy] The policy to apply when the message queue is full.
     * @param {Number} [timeout = 600)] The subscription timeout (in seconds) for a pubsub topic after a /join operation.
     * @param {Number} [maxMessageSize] The maximum allowed size (in bytes) for a pubsub message.
     * @param {module:api/DefaultApi~joinCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/JoinResponse}
     */
    join(topic, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'topic' is set
      if (topic === undefined || topic === null) {
        throw new Error("Missing the required parameter 'topic' when calling join");
      }

      let pathParams = {
      };
      let queryParams = {
        'topic': topic,
        'queue-length': opts['queueLength'],
        'queue-policy': opts['queuePolicy'],
        'timeout': opts['timeout'],
        'max-message-size': opts['maxMessageSize']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = JoinResponse;
      return this.apiClient.callApi(
        '/join', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the leave operation.
     * @callback module:api/DefaultApi~leaveCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Unsubscribe from a pubsub topic
     * Unsubscribe from a pubsub topic, and destroy any stored message for that topic.
     * @param {String} topic The name of the pubsub topic.
     * @param {module:api/DefaultApi~leaveCallback} callback The callback function, accepting three arguments: error, data, response
     */
    leave(topic, callback) {
      let postBody = null;
      // verify the required parameter 'topic' is set
      if (topic === undefined || topic === null) {
        throw new Error("Missing the required parameter 'topic' when calling leave");
      }

      let pathParams = {
      };
      let queryParams = {
        'topic': topic
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/leave', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the list operation.
     * @callback module:api/DefaultApi~listCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/ListResponseInner>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * List subscribed topics
     * @param {Object} opts Optional parameters
     * @param {String} [filterPrefix] Filter topics by a prefix string.
     * @param {String} [filterSuffix] Filter topics by a suffix string.
     * @param {Number} [maxTopic] The maximum number of topics to return.
     * @param {String} [afterTopic] A pagination cursor to list topics after a specified topic.
     * @param {module:api/DefaultApi~listCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/ListResponseInner>}
     */
    list(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'filter-prefix': opts['filterPrefix'],
        'filter-suffix': opts['filterSuffix'],
        'max-topic': opts['maxTopic'],
        'after-topic': opts['afterTopic']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [ListResponseInner];
      return this.apiClient.callApi(
        '/list', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the publish operation.
     * @callback module:api/DefaultApi~publishCallback
     * @param {String} error Error message, if any.
     * @param data This operation does not return a value.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Publish a message in a pubsub topic and signal liveness
     * @param {String} topic The name of the pubsub topic.
     * @param {module:model/PublishMessageProperty} publishMessageProperty 
     * @param {module:api/DefaultApi~publishCallback} callback The callback function, accepting three arguments: error, data, response
     */
    publish(topic, publishMessageProperty, callback) {
      let postBody = publishMessageProperty;
      // verify the required parameter 'topic' is set
      if (topic === undefined || topic === null) {
        throw new Error("Missing the required parameter 'topic' when calling publish");
      }
      // verify the required parameter 'publishMessageProperty' is set
      if (publishMessageProperty === undefined || publishMessageProperty === null) {
        throw new Error("Missing the required parameter 'publishMessageProperty' when calling publish");
      }

      let pathParams = {
      };
      let queryParams = {
        'topic': topic
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = ['application/json'];
      let accepts = ['application/json'];
      let returnType = null;
      return this.apiClient.callApi(
        '/publish', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the read operation.
     * @callback module:api/DefaultApi~readCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ReadResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Read message from a pubsub topic and signal liveness. This consumes the returned messages from the queue
     * @param {String} topic The name of the pubsub topic.
     * @param {Object} opts Optional parameters
     * @param {Number} [maxMessages] The maximum number of messages to read.
     * @param {Boolean} [includeSignature = false)] If true, the response includes the public key and signature for each message.
     * @param {module:api/DefaultApi~readCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ReadResponse}
     */
    read(topic, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'topic' is set
      if (topic === undefined || topic === null) {
        throw new Error("Missing the required parameter 'topic' when calling read");
      }

      let pathParams = {
      };
      let queryParams = {
        'topic': topic,
        'max-messages': opts['maxMessages'],
        'include-signature': opts['includeSignature']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = ReadResponse;
      return this.apiClient.callApi(
        '/read', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the readAll operation.
     * @callback module:api/DefaultApi~readAllCallback
     * @param {String} error Error message, if any.
     * @param {Array.<module:model/ReadAllResponseInner>} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Read messages from multiple topic at once and signal liveness. This consumes the returned messages from the queue.
     * @param {Object} opts Optional parameters
     * @param {Number} [maxMessages] The maximum number of messages to read.
     * @param {String} [filterPrefix] Filter topics by a prefix string.
     * @param {String} [filterSuffix] Filter topics by a suffix string.
     * @param {Boolean} [includeSignature = false)] If true, the response includes the public key and signature for each message.
     * @param {module:api/DefaultApi~readAllCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Array.<module:model/ReadAllResponseInner>}
     */
    readAll(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'max-messages': opts['maxMessages'],
        'filter-prefix': opts['filterPrefix'],
        'filter-suffix': opts['filterSuffix'],
        'include-signature': opts['includeSignature']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['application/json'];
      let returnType = [ReadAllResponseInner];
      return this.apiClient.callApi(
        '/read-all', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
